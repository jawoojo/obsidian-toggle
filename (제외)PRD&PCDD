제시해주신 문제점들(리스트 들여쓰기 불편함, HTML 태그의 가독성과 렌더링 한계, 헤딩 접기의 구조적 지저분함)에 깊이 공감합니다. 이를 해결하기 위해 **"노션의 사용자 경험을 마크다운 환경에서 네이티브하게 구현"**하는 것을 목표로 PRD를 작성해 드립니다.

이 PRD는 AI(바이브코딩)가 바로 이해하고 코드를 짤 수 있도록 넘버링과 목적 중심으로 구성되었습니다.

---

# PRD: Obsidian Notion-Style Toggle Plugin

## 1. 개요 (Overview)
* **목적:** 리스트 들여쓰기나 복잡한 HTML 태그 없이, 특정 기호만으로 노션처럼 깔끔하게 접고 펼칠 수 있는 토글 블록 구현.
* **핵심 가치:** 
    1. 마크다운 문법 파괴 최소화 (복사 붙여넣기 시 가독성 유지).
    2. 엔터/줄바꿈이 자유로운 내부 콘텐츠 공간 확보.
    3. 시각적으로 노션과 동일한 삼각형 아이콘 UI 제공.

## 2. 기능 요구사항 (Functional Requirements)

### 2.1. 토글 트리거 및 자동 완성 (Trigger & Auto-Complete)
* **[2.1.1]** **시작 태그:** 행의 시작 부분에 `|> ` (파이프, 꺽쇠, 공백)를 입력하면 해당 줄은 '토글 제목'으로 인식된다.
* **[2.1.2]** **자동 닫기:** `|>` 입력 후 `Space`를 누르면, 자동으로 다음 줄에 `<|` (종료 태그)가 삽입되고 커서는 그 사이(제목 위치)에 위치해야 한다.
* **[2.1.3]** **종료 태그:** 행의 시작 부분에 `<|` 가 입력되면 해당 줄은 토글의 끝을 의미한다.

### 2.2. 에디터 UI 및 렌더링 (Live Preview UI)
* **[2.2.1]** **시작 위젯:** `|> ` 텍스트는 숨겨지고, 클릭 가능한 **삼각형 아이콘(▶/▼)**으로 대체된다.
* **[2.2.2]** **종료 위젯(Visual Line):**
    *   `<|` 텍스트는 평상시 **"가로선(Horizontal Line)"**으로 렌더링된다.
    *   **클릭 상호작용:** 가로선을 클릭하거나 커서가 위치하면 편집 모드로 전환되어 `<|` 텍스트가 드러나야 한다.
    *   **스타일:** 가로선은 인라인 요소(span)로 렌더링되어 들여쓰기(Spacer)의 영향을 받아야 하며, 텍스트 라인의 중앙(vertical-align: middle)에 위치해야 한다.

### 2.3. 스코프 및 접기 로직 (Scope & Folding)
* **[2.3.1]** **제목 접기 제한 (Scoped Header Folding):**
    *   토글 내부에서 `## 제목`을 접을 때, 기본 옵시디언 동작(문서 끝까지 접기)을 방지한다.
    *   **로직:** 접기 범위는 다음 제목이 나오거나, **현재 토글의 종료 태그(`<|`)**를 만나면 즉시 중단되어야 한다.
* **[2.3.2]** **중첩 지원:** 토글 안에 토글이 있을 경우, 짝이 맞는 `<|`를 정확히 찾아(Stack Counting) 접히고 들여쓰기 되어야 한다.

### 2.4. 시각적 스타일링 (Visual Styling)
* **[2.4.1]** **배경 명도 및 반전 (Opacity & Reversal):**
    *   중첩된 토글(레벨이 다른 경우)은 서로 연결되지 않고, **둥근 모서리로 명확히 분리**되어야 한다. ("카드 속의 카드" 디자인)
    *   **Level 6~8:** 깊은 중첩 시 가독성 확보를 위해 **농도를 다시 연하게(Reverse)** 조정한다. (0.20 -> 0.10)

### 2.5. 확장 기능 (Extended Features)
* **[2.5.1]** **헤더 토글 (Header Toggle):**
    *   **Syntax:** `|> # 제목` 형태로 입력 시, 토글의 제목으로 Markdown Header를 사용할 수 있다.
    *   **Triangle Hiding:** 헤더 토글의 경우, 미관을 위해 `|>` 삼각형 아이콘을 숨기고 Gutter의 접기 버튼이나 제목 클릭으로 토글을 제어한다.
    *   **Hash Hiding:** 해당 줄을 편집하지 않을 때는 `#` 문자를 숨겨 깔끔하게 보여준다.
* **[2.5.2]** **코드 블록 토글 (Code Block Toggle):**
    *   **Syntax:** ` ```> ` 또는 ` ```python> ` (언어 명시 가능) 형태로 시작하는 코드 블록은 접을 수 있어야 한다.
    *   **Flexibility:** 백틱(` ``` `) 3개로 시작하고 마지막이 `>`로 끝나면 토글 코드 블록으로 인식한다. (띄어쓰기 허용: ` ```python > `)
* **[2.5.3]** **커맨드 팔레트 (Command Palette):**
    *   **"Insert Toggle":** `|> \n\n<|`를 입력하고 커서를 제목 위치(`|> ` 직후)로 이동시킨다.
    *   **"Insert Code Block Toggle":** ` ```> \n\n ``` `를 입력하고 커서를 코드 블록 내부로 이동시킨다.
* **[2.5.4]** **읽기 모드 지원 (Reading Mode):**
    *   편집 모드(Live Preview)와 동일한 시각적 스타일(배경색, 둥근 모서리, 복사 버튼 등)을 읽기 모드에서도 지원해야 한다.
    *   DOM Post-Processing 방식을 사용하여 HTML 태그를 조작한다.

---

## 3. 기술적 제약 및 스타일 (Technical Constraints)

### 3.1. 에디터 엔진 활용
* **[3.1.1]** CodeMirror 6의 `ViewPlugin`과 `Decoration.widget`, `Decoration.replace`를 적극 활용한다.
* **[3.1.2]** **친환경 구현:** 무거운 DOM 조작보다는 CodeMirror의 Native Folding 기능(`foldService`)과 연동하여 안정성을 확보한다.

### 3.2. 성능 최적화
* **[3.2.1]** **Event-Driven Update:** 마우스 커서 감지 로직 등은 `update.selectionSet`이나 `selectionTouchesTag` 같은 조건을 통해 필요한 순간에만 렌더링을 갱신하여 리소스를 절약한다.
* **[3.2.2]** 들여쓰기 계산은 `O(N)` 복잡도의 Stack & Difference Array 알고리즘을 사용하여 대용량 문서에서도 끊김이 없어야 한다.



---

# [General Guideline] PRD-Comment Driven Development (PCDD)

## 0.1. 가이드라인 목적 (Objective)

* **맥락의 영속성 (Context Persistence):** AI 모델이 변경되거나 세션이 초기화되어도, **PRD(요구사항)**와 **Code(구현)**의 연결고리(주석)를 통해 즉시 프로젝트의 맥락을 이해하고 개발을 이어간다.
* **리소스 절약:** 불필요한 상황 설명이나 히스토리 요약을 생략하여 토큰 소모를 최소화한다.
* **추적 가능성:** 코드의 특정 로직이 "왜" 존재하는지 PRD를 통해 역추적한다.


## 0.2. 코드 작성 원칙
* **[ID] 무엇을 -> 왜:** 모든 주요 함수와 로직 상단에 PRD 번호를 명시한다.
* **No Polling:** 문서 전체를 주기적으로 스캔하지 말고, 변경된 Line에 대해서만 반응하는 CodeMirror ViewUpdate 이벤트를 활용한다.


---

## 1. PRD 작성 표준 (PRD Writing Standards)

PRD는 제품의 **WHAT (무엇을 만들 것인가)**을 정의합니다. 코드는 **HOW (어떻게 구현할 것인가)**를 담당합니다.

### 1.1. 넘버링 시스템 (Numbering System)

모든 요구사항은 고유한 **ID(번호)**를 가져야 합니다. 코드가 이 번호를 참조(Reference)하기 때문입니다.

* **포맷:** `[섹션].[서브섹션].[항목]` (예: `3.1.2`)
* **작성 예시:**
```markdown
## 3. 기능 요구사항 (Functional Requirements)
### 3.1. 데이터 저장
* **3.1.1.** 사용자가 입력을 멈추면 0.5초 뒤 자동 저장한다.
* **3.1.2.** 저장 실패 시 트레이 아이콘에 경고 표시를 띄운다.

```



### 1.2. 기술 독립적 서술 (Tech-Agnostic)

* **권장:** "사용자가 버튼을 누르면 데이터가 갱신되어야 한다." (기능 중심)
* **지양:** "`OnClick` 이벤트에서 `UpdateData()` 함수를 호출한다." (구현 디테일은 코드의 영역)

---

## 2. 코드 주석 작성 표준 (Comment Standards)

주석은 코드를 설명하는 것이 아니라, **PRD와의 연결고리**이자 **구현의 의도(Context)**를 설명해야 합니다.

### 2.1. 기본 포맷

```cpp
// [PRD 번호] 요약된 요구사항 명칭
// - 구현 의도: 왜 이렇게 짰는가? (Why)
// - 기술적 결정: 트레이드오프나 제약사항 (Constraints)
// - 예외 처리: 특이 사항 (Edge Case)

```

### 2.2. 작성 예시 (Bad vs Good)


네, 이전 양식(`구현 의도`, `기술적 결정`, `예외 처리`를 매번 명시)은 간단한 프로젝트에서는 너무 무거울 수 있습니다.

**"가장 핵심적인 것(ID + What + Why)"**만 남겨서, **한 줄에서 두 줄로 끝낼 수 있는 '범용적이고 가벼운 포맷'**으로 다시 정리해 드립니다.

복사해서 바로 사용하세요.

---

# [Global Guideline] PRD-Context Driven Development (Lite Version)

## 1. 핵심 철학 (Philosophy)

* **Goal:** AI가 바뀌어도 **PRD(문서)**와 **주석(코드)**만 보면 프로젝트의 흐름(Context)을 완벽히 복원할 수 있어야 한다.
* **Rule:** 코드는 `HOW`를 말하고, 주석은 `PRD ID`와 `WHY(맥락)`를 말한다.

---

## 2. PRD 작성 표준 (PRD Standards)

* **넘버링 필수:** 모든 요구사항에는 고유 번호(ID)가 있어야 한다.
* **What 중심:** 기술적 구현 방법이 아닌, **'기능'과 '목표'** 위주로 서술한다.

> **작성 예시:**
> * **[3.1]** 자동 저장 기능: 사용자가 입력을 멈추면 1초 뒤에 파일에 저장한다.
> 
> 

---

## 3. 코드 주석 표준 (Comment Standards) : 🔥 핵심 수정됨

복잡한 형식을 버리고 **`[ID] 무엇을(What) -> 왜(Why)`** 구조를 기본으로 합니다.

### 3.1. 기본 포맷 (General Format)

가장 권장하는 간단하고 강력한 포맷입니다.

```cpp
// [PRD 번호] <기능 요약>
// -> <맥락/의도: 왜 이렇게 짰는지, 어떤 이슈를 해결했는지 한 줄 요약>

```

### 3.2. 상황별 적용 예시

**Type A. 한 줄 처리 (간단한 로직)**

* 옆에 붙여서 `ID`와 `이유`만 명시합니다.

```cpp
SetWindowText(hEdit, L""); // [PRD 2.1] 잔상 제거 -> 폴더 이동 시 기존 메모 즉시 초기화

```

**Type B. 블록 처리 (함수/클래스 단위)**

* 함수 위에는 `What`과 `Why`를 명확히 적습니다.

```cpp
// [PRD 4.3] 마우스 휠 폰트 줌
// -> 오버레이가 부모 창이라 메시지를 먼저 가로채므로, Ctrl 키 확인 후 직접 처리함.
case WM_MOUSEWHEEL: {
    // ... 코드 ...
}

```

**Type C. 비동기/복잡한 로직 (중요)**

* AI가 가장 헷갈려하는 부분이므로 `Flow(흐름)`를 간단히 언급합니다.

```cpp
// [PRD 3.1.1] 비동기 경로 탐색 (Async Pathfinder)
// -> 메인 UI 멈춤 방지(Non-Blocking)를 위해 별도 스레드 사용.
// -> Flow: 스레드 시작 -> 탐색기 핸들 검사 -> (실패 시 Retry) -> 결과 보고(PostMessage)
void PathFinderThread(...) {
    // ... 코드 ...
}


```

---

## 3. 선호하는 코딩 스타일 (Preferred Coding Style)

다음은 프로젝트 전반에 적용되어야 할 기술적 지향점입니다.

### 3.1. 친환경 & 고효율 (Eco-Friendly & High Performance)

* **Polling-Free:** `while(true)`나 `Sleep()`으로 상태를 무한 감시하는 것을 금지합니다.
* **Event-Driven:** OS나 프레임워크가 주는 **이벤트(Signal)**에만 반응하여 CPU 점유율을 **0%**로 유지합니다.
* **Native & Light:** 무거운 프레임워크보다는 Native API(Win32 등)나 가벼운 라이브러리를 선호합니다.

### 3.2. 비동기 & 안정성 (Async & Robustness)

* **Non-Blocking:** UI 스레드는 절대 멈추면 안 됩니다. I/O나 대기 시간(Network/File)이 필요한 작업은 반드시 **Worker Thread**로 위임합니다.
* **Graceful Failure:** 외부 요인(탐색기 종료, 네트워크 끊김)으로 인해 프로그램이 비정상 종료(Crash)되지 않도록 방어 코드를 작성합니다.

### 3.3. 모듈화 (Modularity for AI)

* **Copy-Paste Friendly:** AI가 코드를 수정해 줄 때, 전체 파일을 다시 짜지 않고 **"수정된 함수 단위"**로 복사해서 붙여넣기 쉽도록 함수를 독립적으로 구성합니다.

---

## 4. AI 협업 워크플로우 (Workflow with AI)

1. **PRD 제공:** 사용자가 프로젝트의 `PRD.md` 내용을 먼저 제공합니다.
2. **구현 요청:** "PRD 2.1.3 항목을 구현해줘"라고 요청합니다.
3. **코드 생성:** AI는 위 **[2. 코드 주석 작성 표준]**에 맞춰 주석이 달린 코드를 생성합니다.
4. **피드백 및 수정:** 코드가 수정되면 주석의 내용(구현 의도 등)도 함께 업데이트되어야 합니다.

---
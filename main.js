/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TogglePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// editor_extension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");
var START_TAG = "|> ";
var END_TAG = "<|";
var ToggleWidget = class extends import_view.WidgetType {
  constructor(isFolded, foldStart, foldEnd) {
    super();
    this.isFolded = isFolded;
    this.foldStart = foldStart;
    this.foldEnd = foldEnd;
  }
  toDOM(view) {
    const span = document.createElement("span");
    span.className = "toggle-widget";
    span.textContent = this.isFolded ? "\u25B6" : "\u25BC";
    span.style.cursor = "pointer";
    span.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this.isFolded) {
        view.dispatch({
          effects: import_language.unfoldEffect.of({ from: this.foldStart, to: this.foldEnd })
        });
      } else {
        view.dispatch({
          effects: import_language.foldEffect.of({ from: this.foldStart, to: this.foldEnd })
        });
      }
    };
    return span;
  }
  ignoreEvent() {
    return true;
  }
};
var CopyWidget = class extends import_view.WidgetType {
  constructor(startLineNo, endLineNo) {
    super();
    this.startLineNo = startLineNo;
    this.endLineNo = endLineNo;
  }
  toDOM(view) {
    const span = document.createElement("span");
    span.className = "toggle-copy-btn";
    const iconInfo = (0, import_obsidian.getIcon)("copy");
    if (iconInfo) {
      span.appendChild(iconInfo);
    } else {
      span.textContent = "Copy";
    }
    span.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      const doc = view.state.doc;
      if (this.endLineNo <= this.startLineNo + 1) {
        navigator.clipboard.writeText("");
        return;
      }
      const fromPos = doc.line(this.startLineNo + 1).from;
      const toPos = doc.line(this.endLineNo - 1).to;
      const text = doc.sliceString(fromPos, toPos);
      navigator.clipboard.writeText(text);
    };
    return span;
  }
  ignoreEvent() {
    return true;
  }
};
var EndTagWidget = class extends import_view.WidgetType {
  constructor(pos, indentPx, isError = false) {
    super();
    this.pos = pos;
    this.indentPx = indentPx;
    this.isError = isError;
  }
  toDOM(view) {
    const span = document.createElement("span");
    if (this.isError) {
      span.className = "toggle-end-error";
      span.textContent = "<| (Unmatched)";
    } else {
      span.className = "toggle-end-widget";
    }
    span.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      view.dispatch({
        selection: { anchor: this.pos }
      });
      view.focus();
    };
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var HeaderHashWidget = class extends import_view.WidgetType {
  toDOM(view) {
    const span = document.createElement("span");
    span.className = "toggle-header-hash-widget";
    return span;
  }
};
function findMatchingEndLine(doc, startLineNo) {
  let stack = 1;
  for (let i = startLineNo + 1; i <= doc.lines; i++) {
    const lineText = doc.line(i).text.trimStart();
    if (lineText.startsWith(START_TAG)) {
      stack++;
    } else if (lineText.startsWith(END_TAG)) {
      stack--;
      if (stack === 0) {
        return i;
      }
    }
  }
  return -1;
}
var notionFoldService = import_language.foldService.of((state, lineStart, lineEnd) => {
  const line = state.doc.lineAt(lineStart);
  const text = line.text;
  if (text.startsWith(START_TAG)) {
    const endLineNo = findMatchingEndLine(state.doc, line.number);
    if (endLineNo !== -1) {
      const nextLine = state.doc.line(endLineNo);
      return { from: line.to, to: nextLine.to };
    }
  }
  if (text.trimStart().startsWith("#")) {
    const match = text.match(/^(#+)\s/);
    if (!match)
      return null;
    const headerLevel = match[1].length;
    const doc = state.doc;
    let endLineNo = -1;
    let toggleStack = 0;
    for (let i = line.number + 1; i <= doc.lines; i++) {
      const nextLineText = doc.line(i).text;
      if (nextLineText.startsWith(START_TAG)) {
        toggleStack++;
      } else if (nextLineText.startsWith(END_TAG)) {
        if (toggleStack > 0) {
          toggleStack--;
        } else {
          endLineNo = i - 1;
          break;
        }
      }
      const nextHeaderMatch = nextLineText.match(/^(#+)\s/);
      if (nextHeaderMatch) {
        const nextLevel = nextHeaderMatch[1].length;
        if (nextLevel <= headerLevel) {
          endLineNo = i - 1;
          break;
        }
      }
    }
    if (endLineNo > line.number) {
      return { from: line.to, to: doc.line(endLineNo).to };
    }
  }
  return null;
});
var togglePlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      let shouldUpdate = update.docChanged || update.viewportChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(import_language.foldEffect) || e.is(import_language.unfoldEffect)));
      if (!shouldUpdate && update.selectionSet) {
        const hasOverlap = (state) => {
          for (const range of state.selection.ranges) {
            const line = state.doc.lineAt(range.head);
            const text = line.text.trimStart();
            if (text.startsWith(START_TAG))
              return true;
            if (text.startsWith(END_TAG))
              return true;
          }
          return false;
        };
        const prevOverlap = hasOverlap(update.startState);
        const currOverlap = hasOverlap(update.state);
        if (prevOverlap || currOverlap) {
          shouldUpdate = true;
        }
      }
      if (shouldUpdate) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const doc = view.state.doc;
      const lineCount = doc.lines;
      const ranges = (0, import_language.foldedRanges)(view.state);
      const selection = view.state.selection;
      const decos = [];
      const openStack = [];
      const validRanges = [];
      for (let i = 1; i <= lineCount; i++) {
        const lineText = doc.line(i).text;
        if (lineText.startsWith(START_TAG)) {
          openStack.push(i);
        } else if (lineText.startsWith(END_TAG)) {
          if (openStack.length > 0) {
            const start = openStack.pop();
            validRanges.push({ start, end: i });
          }
        }
      }
      const diff = new Int32Array(lineCount + 2);
      for (const range of validRanges) {
        if (range.end >= range.start) {
          diff[range.start]++;
          diff[range.end + 1]--;
        }
      }
      let currentLevel = 0;
      let prevLevel = 0;
      let runningStack = 0;
      for (let i = 1; i <= lineCount; i++) {
        currentLevel += diff[i];
        const line = doc.line(i);
        const text = line.text;
        const trimmedText = text.trimStart();
        if (currentLevel > 0) {
          const safeLevel = Math.min(currentLevel, 8);
          let classNames = `toggle-bg toggle-bg-level-${safeLevel}`;
          if (trimmedText.startsWith(START_TAG)) {
            classNames += " toggle-round-top";
            try {
              const contentAfter = trimmedText.slice(START_TAG.length);
              const headerMatch = contentAfter.match(/^\s*(#{1,6})\s/);
              if (headerMatch) {
                const level = headerMatch[1].length;
                classNames += ` cm-header cm-header-${level} HyperMD-header HyperMD-header-${level}`;
                let isLineSelected = false;
                for (const r of selection.ranges) {
                  if (r.to >= line.from && r.from <= line.to) {
                    isLineSelected = true;
                    break;
                  }
                }
                if (!isLineSelected) {
                  const indentLen = text.length - trimmedText.length;
                  const hashStart = line.from + indentLen + START_TAG.length + headerMatch.index;
                  const hashEnd = hashStart + headerMatch[0].length;
                  if (hashEnd <= line.to) {
                    decos.push({
                      from: hashStart,
                      to: hashEnd,
                      deco: import_view.Decoration.replace({
                        widget: new HeaderHashWidget(),
                        inclusive: true
                      })
                    });
                  }
                }
              }
            } catch (e) {
            }
          }
          if (trimmedText.startsWith(END_TAG)) {
            classNames += " toggle-round-bot";
          }
          decos.push({
            from: line.from,
            to: line.from,
            deco: import_view.Decoration.line({
              class: classNames
            })
          });
        }
        prevLevel = currentLevel;
        if (trimmedText.startsWith(START_TAG)) {
          runningStack++;
          const indentLen = text.length - trimmedText.length;
          const rangeFrom = line.from + indentLen;
          const rangeTo = rangeFrom + START_TAG.length;
          let isSelected = false;
          for (const r of selection.ranges) {
            if (r.to >= rangeFrom && r.from <= rangeTo) {
              isSelected = true;
              break;
            }
          }
          if (!isSelected) {
            const endLineNo = findMatchingEndLine(doc, i);
            if (endLineNo !== -1) {
              const foldStart = line.to;
              const foldEnd = doc.line(endLineNo).to;
              let isFolded = false;
              ranges.between(foldStart, foldEnd, (from, to) => {
                if (from === foldStart && to === foldEnd)
                  isFolded = true;
              });
              decos.push({
                from: rangeFrom,
                to: rangeTo,
                deco: import_view.Decoration.replace({
                  widget: new ToggleWidget(isFolded, foldStart, foldEnd),
                  inclusive: true
                })
              });
            }
          }
        }
        if (trimmedText.startsWith(END_TAG)) {
          const indentLen = text.length - trimmedText.length;
          const rangeFrom = line.from + indentLen;
          const rangeTo = rangeFrom + END_TAG.length;
          const isOrphan = runningStack === 0;
          if (!isOrphan) {
            runningStack--;
          }
          let isSelected = false;
          for (const r of selection.ranges) {
            if (r.to >= rangeFrom && r.from <= rangeTo) {
              isSelected = true;
              break;
            }
          }
          if (!isSelected && !isOrphan) {
            decos.push({
              from: rangeFrom,
              to: rangeTo,
              deco: import_view.Decoration.replace({
                widget: new EndTagWidget(rangeFrom, 0),
                inclusive: true
              })
            });
          }
        }
        if (trimmedText.startsWith(START_TAG)) {
          const endLineNo = findMatchingEndLine(doc, i);
          if (endLineNo !== -1) {
            decos.push({
              from: line.to,
              // Append to end of line
              to: line.to,
              deco: import_view.Decoration.widget({
                widget: new CopyWidget(i, endLineNo),
                side: 1
              })
            });
          }
        }
        if (text.startsWith(END_TAG)) {
          const rangeFrom = line.from;
          const rangeTo = line.from + END_TAG.length;
          const isOrphan = runningStack === 0;
          if (!isOrphan) {
            runningStack--;
          }
          let isSelected = false;
          for (const r of selection.ranges) {
            if (r.to >= rangeFrom && r.from <= rangeTo) {
              isSelected = true;
              break;
            }
          }
          if (!isSelected && !isOrphan) {
            decos.push({
              from: rangeFrom,
              to: rangeTo,
              deco: import_view.Decoration.replace({
                widget: new EndTagWidget(rangeFrom, 0),
                inclusive: true
              })
            });
          }
        }
      }
      decos.sort((a, b) => {
        if (a.from !== b.from)
          return a.from - b.from;
        return 0;
      });
      const builder = new import_state.RangeSetBuilder();
      for (const d of decos) {
        builder.add(d.from, d.to, d.deco);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var autoCloseKeymap = import_state.Prec.highest(import_view.keymap.of([{
  key: "Space",
  run: (view) => {
    const state = view.state;
    const ranges = state.selection.ranges;
    if (ranges.length !== 1)
      return false;
    const range = ranges[0];
    if (!range.empty)
      return false;
    const pos = range.head;
    const prevChars = state.doc.sliceString(pos - 2, pos);
    if (prevChars === "|>") {
      const insertText = " \n\n<|";
      view.dispatch({
        changes: { from: pos, insert: insertText },
        selection: { anchor: pos + 1 }
      });
      return true;
    }
    return false;
  }
}]));
var toggleExtension = [
  notionFoldService,
  togglePlugin,
  autoCloseKeymap
];

// main.ts
var TogglePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("Loading Toggle Plugin V3.1 (Nested Toggles + Native)");
    this.registerEditorExtension(toggleExtension);
  }
  onunload() {
    console.log("Unloading Toggle Plugin");
  }
};

/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TogglePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// editor_extension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");
var START_TAG = "|> ";
var END_TAG = "<|";
var ToggleWidget = class extends import_view.WidgetType {
  constructor(isFolded, foldStart, foldEnd, invisible = false) {
    super();
    this.isFolded = isFolded;
    this.foldStart = foldStart;
    this.foldEnd = foldEnd;
    this.invisible = invisible;
  }
  toDOM(view) {
    const span = document.createElement("span");
    span.className = "toggle-widget";
    if (this.invisible) {
      span.style.display = "none";
    } else {
      span.textContent = this.isFolded ? "\u25B6" : "\u25BC";
      span.style.cursor = "pointer";
      span.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.isFolded) {
          view.dispatch({
            effects: import_language.unfoldEffect.of({ from: this.foldStart, to: this.foldEnd })
          });
          setTimeout(() => {
            const pos = this.foldEnd;
            view.dispatch({
              changes: { from: pos, insert: " " },
              annotations: import_state.Transaction.addToHistory.of(false)
            });
            setTimeout(() => {
              view.dispatch({
                changes: { from: pos, to: pos + 1, insert: "" },
                annotations: import_state.Transaction.addToHistory.of(false)
              });
            }, 5);
          }, 5);
        } else {
          view.dispatch({
            effects: import_language.foldEffect.of({ from: this.foldStart, to: this.foldEnd })
          });
        }
      };
    }
    return span;
  }
  ignoreEvent() {
    return true;
  }
};
var CopyWidget = class extends import_view.WidgetType {
  constructor(startLineNo, endLineNo) {
    super();
    this.startLineNo = startLineNo;
    this.endLineNo = endLineNo;
  }
  toDOM(view) {
    const span = document.createElement("span");
    span.className = "toggle-copy-btn";
    const iconInfo = (0, import_obsidian.getIcon)("copy");
    if (iconInfo) {
      span.appendChild(iconInfo);
    } else {
      span.textContent = "Copy";
    }
    span.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      const doc = view.state.doc;
      if (this.endLineNo <= this.startLineNo + 1) {
        navigator.clipboard.writeText("");
        return;
      }
      const fromPos = doc.line(this.startLineNo + 1).from;
      const toPos = doc.line(this.endLineNo - 1).to;
      const text = doc.sliceString(fromPos, toPos);
      navigator.clipboard.writeText(text);
    };
    return span;
  }
  ignoreEvent() {
    return true;
  }
};
var EndTagWidget = class extends import_view.WidgetType {
  constructor(pos, indentPx, isError = false) {
    super();
    this.pos = pos;
    this.indentPx = indentPx;
    this.isError = isError;
  }
  toDOM(view) {
    const span = document.createElement("span");
    if (this.isError) {
      span.className = "toggle-end-error";
      span.textContent = "<| (Unmatched)";
    } else {
      span.className = "toggle-end-widget";
    }
    span.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      view.dispatch({
        selection: { anchor: this.pos }
      });
      view.focus();
    };
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var HeaderHashWidget = class extends import_view.WidgetType {
  toDOM(view) {
    const span = document.createElement("span");
    span.className = "toggle-header-hash-widget";
    return span;
  }
};
function findMatchingEndLine(doc, startLineNo) {
  let stack = 1;
  for (let i = startLineNo + 1; i <= doc.lines; i++) {
    const lineText = doc.line(i).text.trimStart();
    if (lineText.startsWith(START_TAG)) {
      stack++;
    } else if (lineText.startsWith(END_TAG)) {
      stack--;
      if (stack === 0) {
        return i;
      }
    }
  }
  return -1;
}
var notionFoldService = import_language.foldService.of((state, lineStart, lineEnd) => {
  const line = state.doc.lineAt(lineStart);
  const text = line.text;
  if (text.startsWith(START_TAG)) {
    const endLineNo = findMatchingEndLine(state.doc, line.number);
    if (endLineNo !== -1) {
      const nextLine = state.doc.line(endLineNo);
      return { from: line.to, to: nextLine.to };
    }
  }
  if (text.trimStart().startsWith("#")) {
    const match = text.match(/^(#+)\s/);
    if (!match)
      return null;
    const headerLevel = match[1].length;
    const doc = state.doc;
    let endLineNo = -1;
    let toggleStack = 0;
    for (let i = line.number + 1; i <= doc.lines; i++) {
      const nextLineText = doc.line(i).text;
      if (nextLineText.startsWith(START_TAG)) {
        toggleStack++;
      } else if (nextLineText.startsWith(END_TAG)) {
        if (toggleStack > 0) {
          toggleStack--;
        } else {
          endLineNo = i - 1;
          break;
        }
      }
      const nextHeaderMatch = nextLineText.match(/^(#+)\s/);
      if (nextHeaderMatch) {
        const nextLevel = nextHeaderMatch[1].length;
        if (nextLevel <= headerLevel) {
          endLineNo = i - 1;
          break;
        }
      }
    }
    if (endLineNo > line.number) {
      return { from: line.to, to: doc.line(endLineNo).to };
    }
  }
  const trimmed = text.trimStart();
  const backtickMatch = trimmed.match(/^`{3}.*>\s*$/);
  const tildeMatch = trimmed.match(/^~{3}.*>\s*$/);
  if (backtickMatch || tildeMatch) {
    const isBacktick = !!backtickMatch;
    const isTilde = !!tildeMatch;
    const endToken = isBacktick ? "```" : "~~~";
    let codeBlockEndLine = -1;
    for (let i = line.number + 1; i <= state.doc.lines; i++) {
      const nextLineText = state.doc.line(i).text.trimStart();
      if (nextLineText.startsWith(endToken)) {
        codeBlockEndLine = i;
        break;
      }
    }
    if (codeBlockEndLine !== -1) {
      const endLine = state.doc.line(codeBlockEndLine);
      return { from: line.to, to: endLine.to };
    }
  }
  return null;
});
var togglePlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      let shouldUpdate = update.docChanged || update.viewportChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(import_language.foldEffect) || e.is(import_language.unfoldEffect)));
      if (!shouldUpdate && update.selectionSet) {
        const hasOverlap = (state) => {
          for (const range of state.selection.ranges) {
            const line = state.doc.lineAt(range.head);
            const text = line.text.trimStart();
            if (text.startsWith(START_TAG))
              return true;
            if ((text.startsWith("```") || text.startsWith("~~~")) && /^(```|~~~).*>\s*$/.test(text))
              return true;
            if (text.startsWith(END_TAG))
              return true;
          }
          return false;
        };
        const prevOverlap = hasOverlap(update.startState);
        const currOverlap = hasOverlap(update.state);
        if (prevOverlap || currOverlap) {
          shouldUpdate = true;
        }
      }
      if (shouldUpdate) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const doc = view.state.doc;
      const lineCount = doc.lines;
      const ranges = (0, import_language.foldedRanges)(view.state);
      const selection = view.state.selection;
      const decos = [];
      const openStack = [];
      const validRanges = [];
      for (let i = 1; i <= lineCount; i++) {
        const lineText = doc.line(i).text;
        if (lineText.startsWith(START_TAG)) {
          openStack.push(i);
        } else if (lineText.startsWith(END_TAG)) {
          if (openStack.length > 0) {
            const start = openStack.pop();
            validRanges.push({ start, end: i });
          }
        }
      }
      const diff = new Int32Array(lineCount + 2);
      for (const range of validRanges) {
        if (range.end >= range.start) {
          diff[range.start]++;
          diff[range.end + 1]--;
        }
      }
      let currentLevel = 0;
      let prevLevel = 0;
      let runningStack = 0;
      let inCodeBlock = false;
      for (let i = 1; i <= lineCount; i++) {
        currentLevel += diff[i];
        const line = doc.line(i);
        const text = line.text;
        const trimmedText = text.trimStart();
        if (currentLevel > 0) {
          const safeLevel = Math.min(currentLevel, 8);
          let classNames = `toggle-bg toggle-bg-level-${safeLevel}`;
          if (trimmedText.startsWith(START_TAG)) {
            classNames += " toggle-round-top";
            try {
              const contentAfter = trimmedText.slice(START_TAG.length);
              const headerMatch = contentAfter.match(/^\s*(#{1,6})\s/);
              if (headerMatch) {
                const level = headerMatch[1].length;
                classNames += ` cm-header cm-header-${level} HyperMD-header HyperMD-header-${level}`;
                let isLineSelected = false;
                for (const r of selection.ranges) {
                  if (r.to >= line.from && r.from <= line.to) {
                    isLineSelected = true;
                    break;
                  }
                }
                if (!isLineSelected) {
                  const indentLen = text.length - trimmedText.length;
                  const hashStart = line.from + indentLen + START_TAG.length + headerMatch.index;
                  const hashEnd = hashStart + headerMatch[0].length;
                  if (hashEnd <= line.to) {
                    decos.push({
                      from: hashStart,
                      to: hashEnd,
                      deco: import_view.Decoration.replace({
                        widget: new HeaderHashWidget(),
                        inclusive: true
                      })
                    });
                  }
                }
              }
            } catch (e) {
            }
          }
          if (trimmedText.startsWith(END_TAG)) {
            classNames += " toggle-round-bot";
          }
          decos.push({
            from: line.from,
            to: line.from,
            deco: import_view.Decoration.line({
              class: classNames
            })
          });
        }
        prevLevel = currentLevel;
        if (trimmedText.startsWith("```") || trimmedText.startsWith("~~~")) {
          const isCodeBlockToggle = /^(```|~~~).*>\s*$/.test(trimmedText);
          if (!inCodeBlock && isCodeBlockToggle) {
            const indentLen = text.length - trimmedText.length;
            const rangeFrom = line.from + indentLen;
            const rangeTo = rangeFrom + trimmedText.length;
            const endToken = trimmedText.startsWith("```") ? "```" : "~~~";
            let codeBlockEndLine = -1;
            for (let k = i + 1; k <= lineCount; k++) {
              const nextLineText = doc.line(k).text.trimStart();
              if (nextLineText.startsWith(endToken)) {
                codeBlockEndLine = k;
                break;
              }
            }
            if (codeBlockEndLine !== -1) {
              const foldStart = line.to;
              const foldEnd = doc.line(codeBlockEndLine).to;
              let isFolded = false;
              ranges.between(foldStart, foldEnd, (from, to) => {
                if (from === foldStart && to === foldEnd)
                  isFolded = true;
              });
              let isSelected = false;
              for (const r of selection.ranges) {
                if (r.to >= rangeFrom && r.from <= rangeTo) {
                  isSelected = true;
                  break;
                }
              }
              if (!isSelected) {
                decos.push({
                  from: rangeFrom,
                  to: rangeTo,
                  deco: import_view.Decoration.replace({
                    widget: new ToggleWidget(isFolded, foldStart, foldEnd, false),
                    inclusive: true
                  })
                });
              }
            }
          }
          inCodeBlock = !inCodeBlock;
          continue;
        }
        if (inCodeBlock)
          continue;
        if (trimmedText.startsWith(START_TAG)) {
          runningStack++;
          const indentLen = text.length - trimmedText.length;
          const rangeFrom = line.from + indentLen;
          const rangeTo = rangeFrom + START_TAG.length;
          let isSelected = false;
          for (const r of selection.ranges) {
            if (r.to >= rangeFrom && r.from <= rangeTo) {
              isSelected = true;
              break;
            }
          }
          const contentAfter = trimmedText.slice(START_TAG.length);
          const isHeader = /^\s*(#{1,6})\s/.test(contentAfter);
          if (!isSelected) {
            const endLineNo = findMatchingEndLine(doc, i);
            if (endLineNo !== -1) {
              const foldStart = line.to;
              const foldEnd = doc.line(endLineNo).to;
              let isFolded = false;
              ranges.between(foldStart, foldEnd, (from, to) => {
                if (from === foldStart && to === foldEnd)
                  isFolded = true;
              });
              decos.push({
                from: rangeFrom,
                to: rangeTo,
                deco: import_view.Decoration.replace({
                  widget: new ToggleWidget(isFolded, foldStart, foldEnd, isHeader),
                  // Pass isHeader as invisible flag
                  inclusive: true
                })
              });
            }
          }
        }
        if (trimmedText.startsWith(END_TAG)) {
          const indentLen = text.length - trimmedText.length;
          const rangeFrom = line.from + indentLen;
          const rangeTo = rangeFrom + END_TAG.length;
          const isOrphan = runningStack === 0;
          if (!isOrphan) {
            runningStack--;
          }
          let isSelected = false;
          for (const r of selection.ranges) {
            if (r.to >= rangeFrom && r.from <= rangeTo) {
              isSelected = true;
              break;
            }
          }
          if (!isSelected && !isOrphan) {
            decos.push({
              from: rangeFrom,
              to: rangeTo,
              deco: import_view.Decoration.replace({
                widget: new EndTagWidget(rangeFrom, 0),
                inclusive: true
              })
            });
          }
        }
        if (trimmedText.startsWith(START_TAG)) {
          const endLineNo = findMatchingEndLine(doc, i);
          if (endLineNo !== -1) {
            decos.push({
              from: line.to,
              // Append to end of line
              to: line.to,
              deco: import_view.Decoration.widget({
                widget: new CopyWidget(i, endLineNo),
                side: 1
              })
            });
          }
        }
      }
      decos.sort((a, b) => {
        if (a.from !== b.from)
          return a.from - b.from;
        return 0;
      });
      const builder = new import_state.RangeSetBuilder();
      for (const d of decos) {
        builder.add(d.from, d.to, d.deco);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var autoCloseKeymap = import_state.Prec.highest(import_view.keymap.of([{
  key: "Space",
  run: (view) => {
    const state = view.state;
    const ranges = state.selection.ranges;
    if (ranges.length !== 1)
      return false;
    const range = ranges[0];
    if (!range.empty)
      return false;
    const pos = range.head;
    const prevChars = state.doc.sliceString(pos - 2, pos);
    if (prevChars === "|>") {
      const insertText = " \n\n<|";
      view.dispatch({
        changes: { from: pos, insert: insertText },
        selection: { anchor: pos + 1 }
      });
      return true;
    }
    return false;
  }
}]));
var toggleExtension = [
  notionFoldService,
  togglePlugin,
  autoCloseKeymap
];

// reading_mode_processor.ts
var import_obsidian2 = require("obsidian");
var START_TAG2 = "|> ";
var END_TAG2 = "<|";
function parseLevels(text) {
  const lines = text.split(/\r\n|\r|\n/);
  const levels = new Int32Array(lines.length).fill(0);
  const rounds = new Array(lines.length).fill("");
  const openStack = [];
  const validRanges = [];
  for (let i = 0; i < lines.length; i++) {
    const lineText = lines[i];
    if (lineText.trimStart().startsWith(START_TAG2)) {
      openStack.push(i);
    } else if (lineText.trimStart().startsWith(END_TAG2)) {
      if (openStack.length > 0) {
        const start = openStack.pop();
        validRanges.push({ start, end: i });
      }
    }
  }
  const diff = new Int32Array(lines.length + 1);
  for (const range of validRanges) {
    if (range.end >= range.start) {
      diff[range.start]++;
      diff[range.end + 1]--;
      rounds[range.start] = "top";
      rounds[range.end] = "bot";
    }
  }
  let currentLevel = 0;
  for (let i = 0; i < lines.length; i++) {
    currentLevel += diff[i];
    levels[i] = currentLevel;
  }
  return { levels: Array.from(levels), rounds };
}
async function readingModeProcessor(el, ctx) {
  const sectionInfo = ctx.getSectionInfo(el);
  if (!sectionInfo)
    return;
  const file = app.vault.getAbstractFileByPath(ctx.sourcePath);
  if (!(file instanceof import_obsidian2.TFile))
    return;
  const fileText = await app.vault.cachedRead(file);
  const { levels, rounds } = parseLevels(fileText);
  const lines = fileText.split(/\r\n|\r|\n/);
  const startLine = sectionInfo.lineStart;
  const endLine = sectionInfo.lineEnd;
  let currentLine = startLine;
  const children = Array.from(el.children);
  for (const child of children) {
    if (currentLine > endLine)
      break;
    const lineLevel = levels[currentLine];
    const roundType = rounds[currentLine];
    const lineText = fileText.split(/\r\n|\r|\n/)[currentLine];
    if (lineLevel > 0) {
      const safeLevel = Math.min(lineLevel, 8);
      child.classList.add("toggle-bg", `toggle-bg-level-${safeLevel}`);
      if (roundType === "top")
        child.classList.add("toggle-round-top");
      if (roundType === "bot")
        child.classList.add("toggle-round-bot");
    }
    const trimmedSource = lineText.trimStart();
    if (trimmedSource.startsWith(START_TAG2)) {
      const contentAfter = trimmedSource.slice(START_TAG2.length);
      const headerMatch = contentAfter.match(/^\s*(#{1,6})\s/);
      const isHeader = !!headerMatch;
      const walker = document.createTreeWalker(child, NodeFilter.SHOW_TEXT);
      const firstTextNode = walker.nextNode();
      if (firstTextNode && firstTextNode.nodeValue) {
        let processed = false;
        if (firstTextNode.nodeValue.trimStart().startsWith("|>")) {
          const originalVal = firstTextNode.nodeValue;
          const triggerIdx = originalVal.indexOf("|>");
          if (triggerIdx !== -1) {
            const afterText = originalVal.substring(triggerIdx + 2);
            const beforeText = originalVal.substring(0, triggerIdx);
            firstTextNode.nodeValue = beforeText + (isHeader ? "" : "");
            if (!isHeader) {
              const triangle = document.createElement("span");
              triangle.className = "toggle-widget";
              triangle.textContent = "\u25BC";
              triangle.style.marginRight = "5px";
              if (firstTextNode.parentNode) {
                firstTextNode.parentNode.insertBefore(triangle, firstTextNode.nextSibling);
                const textNodeAfter = document.createTextNode(afterText);
                firstTextNode.parentNode.insertBefore(textNodeAfter, triangle.nextSibling);
              }
            } else {
              if (headerMatch) {
                const cleanTitle = afterText.replace(/^\s*#{1,6}\s/, "");
                if (firstTextNode.parentNode) {
                  const textNodeAfter = document.createTextNode(cleanTitle);
                  firstTextNode.parentNode.insertBefore(textNodeAfter, firstTextNode.nextSibling);
                }
                const level = headerMatch[1].length;
                child.classList.add(`cm-header`, `cm-header-${level}`);
                child.style.fontWeight = "bold";
                child.style.fontSize = `var(--h${level}-size)`;
                child.style.color = `var(--h${level}-color)`;
              } else {
                if (firstTextNode.parentNode) {
                  const textNodeAfter = document.createTextNode(afterText);
                  firstTextNode.parentNode.insertBefore(textNodeAfter, firstTextNode.nextSibling);
                }
              }
            }
          }
        }
      }
      const endLineNo = findMatchingEndLine2(levels, lines, currentLine);
      if (endLineNo !== -1) {
        const copyBtn = document.createElement("span");
        copyBtn.className = "toggle-copy-btn";
        const icon = (0, import_obsidian2.getIcon)("copy");
        if (icon)
          copyBtn.appendChild(icon);
        copyBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const contentLines = lines.slice(currentLine + 1, endLineNo);
          navigator.clipboard.writeText(contentLines.join("\n"));
        };
        child.appendChild(copyBtn);
        child.style.position = "relative";
      }
    }
    if (child.textContent && child.textContent.includes(END_TAG2)) {
      const walker = document.createTreeWalker(child, NodeFilter.SHOW_TEXT);
      let textNode;
      while (textNode = walker.nextNode()) {
        if (textNode.nodeValue && textNode.nodeValue.includes(END_TAG2)) {
          textNode.nodeValue = textNode.nodeValue.replace(/(^|\n)\s*<\|/g, "$1");
        }
      }
    }
    currentLine++;
  }
}
function findMatchingEndLine2(levels, lines, startLine) {
  let stack = 1;
  for (let i = startLine + 1; i < lines.length; i++) {
    const txt = lines[i].trimStart();
    if (txt.startsWith(START_TAG2))
      stack++;
    else if (txt.startsWith(END_TAG2)) {
      stack--;
      if (stack === 0)
        return i;
    }
  }
  return -1;
}

// main.ts
var TogglePlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Toggle Plugin V3.1 (Nested Toggles + Native)");
    this.registerEditorExtension(toggleExtension);
    this.registerMarkdownPostProcessor((el, ctx) => readingModeProcessor(el, ctx));
    this.addCommand({
      id: "insert-toggle",
      name: "Insert Toggle",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          editor.replaceSelection(`|> 
${selection}
<|`);
        } else {
          const start = "|> ";
          const body = "\n\n";
          const end = "<|";
          const cursorBefore = editor.getCursor();
          editor.replaceSelection(start + body + end);
          editor.setCursor({
            line: cursorBefore.line,
            ch: cursorBefore.ch + 3
          });
        }
      }
    });
    this.addCommand({
      id: "insert-code-toggle",
      name: "Insert Code Block Toggle",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          editor.replaceSelection(`\`\`\`> 
${selection}
\`\`\``);
        } else {
          const start = "```> ";
          const body = "\n\n";
          const end = "```";
          const cursorBefore = editor.getCursor();
          editor.replaceSelection(start + body + end);
          editor.setCursor({
            line: cursorBefore.line,
            ch: cursorBefore.ch + 5
          });
        }
      }
    });
  }
  onunload() {
    console.log("Unloading Toggle Plugin");
  }
};
